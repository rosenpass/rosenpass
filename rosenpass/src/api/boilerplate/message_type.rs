use hex_literal::hex;
use rosenpass_util::zerocopy::RefMaker;
use zerocopy::ByteSlice;

use crate::RosenpassError::{self, InvalidApiMessageType};

pub type RawMsgType = u128;

// constants generated by gen-ipc-msg-types:
// hash domain hash of: Rosenpass IPC API -> Rosenpass Protocol Server -> Ping Request
pub const PING_REQUEST: RawMsgType =
    RawMsgType::from_le_bytes(hex!("2397 3ecc c441 704d    0b02 ea31 45d3 4999"));
// hash domain hash of: Rosenpass IPC API -> Rosenpass Protocol Server -> Ping Response
pub const PING_RESPONSE: RawMsgType =
    RawMsgType::from_le_bytes(hex!("4ec7 f6f0 2bbc ba64    48f1 da14 c7cf 0260"));

// hash domain hash of: Rosenpass IPC API -> Rosenpass Protocol Server -> Supply Keypair Request
const SUPPLY_KEYPAIR_REQUEST: RawMsgType =
    RawMsgType::from_le_bytes(hex!("ac91 a5a6 4f4b 21d0    ac7f 9b55 74f7 3529"));
// hash domain hash of: Rosenpass IPC API -> Rosenpass Protocol Server -> Supply Keypair Response
const SUPPLY_KEYPAIR_RESPONSE: RawMsgType =
    RawMsgType::from_le_bytes(hex!("f2dc 49bd e261 5f10    40b7 3c16 ec61 edb9"));

// hash domain hash of: Rosenpass IPC API -> Rosenpass Protocol Server -> Add Listen Socket Request
const ADD_LISTEN_SOCKET_REQUEST: RawMsgType =
    RawMsgType::from_le_bytes(hex!("3f21 434f 87cc a08c    02c4 61e4 0816 c7da"));
// hash domain hash of: Rosenpass IPC API -> Rosenpass Protocol Server -> Add Listen Socket Response
const ADD_LISTEN_SOCKET_RESPONSE: RawMsgType =
    RawMsgType::from_le_bytes(hex!("45d5 0f0d 93f0 6105    98f2 9469 5dfd 5f36"));

pub trait MessageAttributes {
    fn message_size(&self) -> usize;
}

#[derive(Hash, PartialEq, Eq, PartialOrd, Ord, Debug, Clone, Copy)]
pub enum RequestMsgType {
    Ping,
    SupplyKeypair,
    AddListenSocket,
}

#[derive(Hash, PartialEq, Eq, PartialOrd, Ord, Debug, Clone, Copy)]
pub enum ResponseMsgType {
    Ping,
    SupplyKeypair,
    AddListenSocket,
}

impl MessageAttributes for RequestMsgType {
    fn message_size(&self) -> usize {
        match self {
            Self::Ping => std::mem::size_of::<super::PingRequest>(),
            Self::SupplyKeypair => std::mem::size_of::<super::SupplyKeypairRequest>(),
            Self::AddListenSocket => std::mem::size_of::<super::AddListenSocketRequest>(),
        }
    }
}

impl MessageAttributes for ResponseMsgType {
    fn message_size(&self) -> usize {
        match self {
            Self::Ping => std::mem::size_of::<super::PingResponse>(),
            Self::SupplyKeypair => std::mem::size_of::<super::SupplyKeypairResponse>(),
            Self::AddListenSocket => std::mem::size_of::<super::AddListenSocketResponse>(),
        }
    }
}

impl TryFrom<RawMsgType> for RequestMsgType {
    type Error = RosenpassError;

    fn try_from(value: RawMsgType) -> Result<Self, Self::Error> {
        use RequestMsgType as E;
        Ok(match value {
            self::PING_REQUEST => E::Ping,
            self::SUPPLY_KEYPAIR_REQUEST => E::SupplyKeypair,
            self::ADD_LISTEN_SOCKET_REQUEST => E::AddListenSocket,
            _ => return Err(InvalidApiMessageType(value)),
        })
    }
}

impl From<RequestMsgType> for RawMsgType {
    fn from(val: RequestMsgType) -> Self {
        use RequestMsgType as E;
        match val {
            E::Ping => self::PING_REQUEST,
            E::SupplyKeypair => self::SUPPLY_KEYPAIR_REQUEST,
            E::AddListenSocket => self::ADD_LISTEN_SOCKET_REQUEST,
        }
    }
}

impl TryFrom<RawMsgType> for ResponseMsgType {
    type Error = RosenpassError;

    fn try_from(value: RawMsgType) -> Result<Self, Self::Error> {
        use ResponseMsgType as E;
        Ok(match value {
            self::PING_RESPONSE => E::Ping,
            self::SUPPLY_KEYPAIR_RESPONSE => E::SupplyKeypair,
            self::ADD_LISTEN_SOCKET_RESPONSE => E::AddListenSocket,
            _ => return Err(InvalidApiMessageType(value)),
        })
    }
}

impl From<ResponseMsgType> for RawMsgType {
    fn from(val: ResponseMsgType) -> Self {
        use ResponseMsgType as E;
        match val {
            E::Ping => self::PING_RESPONSE,
            E::SupplyKeypair => self::SUPPLY_KEYPAIR_RESPONSE,
            E::AddListenSocket => self::ADD_LISTEN_SOCKET_RESPONSE,
        }
    }
}

pub trait RawMsgTypeExt {
    fn into_request_msg_type(self) -> Result<RequestMsgType, RosenpassError>;
    fn into_response_msg_type(self) -> Result<ResponseMsgType, RosenpassError>;
}

impl RawMsgTypeExt for RawMsgType {
    fn into_request_msg_type(self) -> Result<RequestMsgType, RosenpassError> {
        self.try_into()
    }

    fn into_response_msg_type(self) -> Result<ResponseMsgType, RosenpassError> {
        self.try_into()
    }
}

pub trait RefMakerRawMsgTypeExt {
    fn parse_request_msg_type(self) -> anyhow::Result<RequestMsgType>;
    fn parse_response_msg_type(self) -> anyhow::Result<ResponseMsgType>;
}

impl<B: ByteSlice> RefMakerRawMsgTypeExt for RefMaker<B, RawMsgType> {
    fn parse_request_msg_type(self) -> anyhow::Result<RequestMsgType> {
        Ok(self.parse()?.read().try_into()?)
    }

    fn parse_response_msg_type(self) -> anyhow::Result<ResponseMsgType> {
        Ok(self.parse()?.read().try_into()?)
    }
}
